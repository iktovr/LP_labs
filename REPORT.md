# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Бирюков В.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в прологе похожи на линейные односвязные списки в императивных языках: взятие первого элемента и вставка в начало - O(1), поиск элемента и вставка не в начало - O(N).
Однако, в силу неизменяемости списков, для совершения любой операцию необходимо создавать новый список.
Также обращение к элементам списка не является обращением в привычном смысле, а осуществляется путем унификации некого выражения (например отделения головы и хвоста, или списка с конкретным числом неизвестных элементов) с конкретным списком.

## Задание 1.1: Предикат обработки списка

**Реализация стандартных предикатов**
```prolog
mylength([], 0).
mylength([_|L], N) :- mylength(L, N1), N is N1 + 1.

mymember(X, [X|_]).
mymember(X, [_|L]) :- mymember(X, L).

myappend([], L, L).
myappend([X|L1], L2, [X|L]) :- myappend(L1, L2, L).

mydelete([X|L], X, L).
mydelete([K|L], X, [K|L1]) :- mydelete(L, X, L1).

mypermute([], []).
mypermute(L, [X|P]) :- mydelete(L, X, L1), mypermute(L1, P).

mysublist([], _).
mysublist([H|S], [H|L]) :- mysublist(S, L).
mysublist([H1|S], [H2|L]) :- mysublist([H1|S], L), H1 \= H2.
```

`remove_last(List, Res)` - удаление последнего элемента.

Примеры использования:
```prolog
?- remove_last([1, 2, 3, 4], X).
X = [1, 2, 3] ;
false.
?- remove_last([1, 2, 3, 4], [5, 6]).
false.
?- remove_last([61, 2, X, g, U], [61, 2, X, g]).
true.

?- remove_last_std([1, 2, 3, 4], X).
X = [1, 2, 3] ;
false.
?- remove_last_std([1, 2, 3, 4], [5, 6]).
false.
3 ?- remove_last_std([61, 2, X, g, U], [61, 2, X, g]).
true.
```

Реализация:
```prolog
remove_last([_], []).
remove_last([H|L], [H|R]) :- remove_last(L, R).

% Реализация со стандартными предикатами
remove_last_std(L, R) :- myappend(R, [_], L).
```

Отделяем головы у исходного и результирующего списков, если у исходного списка остался один элемент, результирующий должен быть пустым.

## Задание 1.2: Предикат обработки числового списка

`sorted(List)` - проверка упорядоченности элементов по возрастанию.

Примеры использования:
```prolog
?- sorted([2, 7, 7, 9, 123, 789]).
true ;
false.
?- sorted([67, 89, 12]).
false.

?- sorted_std([2, 7, 7, 9, 123, 789]).
true.
?- sorted_std([67, 89, 12]).
false.
```

Реализация:
```prolog
sorted([]).
sorted([_]).
sorted([X,Y|L]) :- X =< Y, sorted([Y|L]).

% Реализация со стандартными предикатами
unsorted_std(L) :- myappend(_, [X,Y|_], L), X > Y.
sorted_std(L) :- not(unsorted_std(L)).
```

Список отсортирован, если все во всех парах подряд идущих элементов, первый элемент меньше либо равен второго.
Следовательно, отделяем два элемента от списка, проверяем это условие, проверяем список дальше. Список с одним элементом и пустой список считаем отсортированными.

**Примеры совместного использования предикатов**
* Сортировка за O(N!)
```prolog
bad_sort(L, R) :- mypermute(L, R), sorted(R).
```
```prolog
?- bad_sort([9, 32, 8, 3, 2, 6, 1], X).
X = [1, 2, 3, 6, 8, 9, 32] .
```


## Задание 2: Реляционное представление данных

Реляционное представление данных в виде фактов Пролога удобно тем, что позволяет относительно легко записывать данные, создавать новые связи между ними. Это компенсируется более сложным удалением, а также низкой читабельностью и не наглядностью, в отличие от более привычных таблиц.

Представление 2 использует только один предикат для описания связей между данными, являясь прямым аналогом простейшей таблицы со всеми студентами. Это упрощает добавление новых данных, но увеличивает количество фактов. Также, единицей представления является оценка, что увеличивает описание одного человека, являющегося более логичной единицей данных. Однако использование одного предиката позволяет применять встроенные предикаты `bagof`, `setof`, `findall`, что значительно упрощает выполнение запросов.

`average(Subj, X)` - средний балл для предмета.

Примеры использования:
```prolog
?- average('Информатика',X).
X = 3.9285714285714284.
?- average(X,Y).
X = 'Английский язык',
Y = 3.75 ;
X = 'Информатика',
Y = 3.9285714285714284 ;
X = 'Логическое программирование',
Y = 3.9642857142857144 ;
X = 'Математический анализ',
Y = 3.892857142857143 ;
X = 'Психология',
Y = 3.9285714285714284 ;
X = 'Функциональное программирование',
Y = 3.9642857142857144.
```

Реализация:
```prolog
average(Subj, X) :-
	bagof(Mark, Group^Stud^grade(Group, Stud, Subj, Mark), Res),
	sum_list(Res, Sum), length(Res, N),
	X is Sum / N.
```

Используем `bagof` для получения списка оценок для каждого кокретного предмета. Находим его сумму при помощи встроенного предиката `sum_list/2` и длину, при помощи `length/2`. Результат - частное суммы и длины.

`not_passed_group(Group, X)` - количество не сдавших студентов в группе.

Примеры использования:
```prolog
?- not_passed_group(X,Y).
X = 101,
Y = 2 ;
X = 102,
Y = 5 ;
X = 103,
Y = 3 ;
X = 104,
Y = 2.
?- not_passed_group(X,1).
false.
?- not_passed_group(103,X).
X = 3.
```

Реализация:
```prolog
not_passed_group(Group, X) :-
	setof(Stud, Subj^grade(Group, Stud, Subj, 2), Res),
	length(Res, X).
```

Для получения списка студентов, получивших 2, для каждого значения группы, используем `setof`, так как один студент мог не сдать несколько предметов. Результат - длина этого списка.

`not_passed_subj(Subj, X)` - количество студентов, не сдавших предмет.

Примеры использования:
```prolog
?- not_passed_subj('Психология',X).
X = 1.
?- not_passed_subj(X,2).
X = 'Информатика' ;
X = 'Логическое программирование' ;
false.
?- not_passed_subj(X,Y).
X = 'Английский язык',
Y = 4 ;
X = 'Информатика',
Y = 2 ;
X = 'Логическое программирование',
Y = 2 ;
X = 'Математический анализ',
Y = 3 ;
X = 'Психология',
Y = 1 ;
X = 'Функциональное программирование',
Y = 1.
```

Реализация:
```prolog
not_passed_subj(Subj, X) :-
	bagof(Stud, Group^grade(Group, Stud, Subj, 2), Res),
	length(Res, X).
```

Для получения списка студентов, получивших 2, для каждого значения предмета, используем `bagof`, так как у одного студента есть единственная оценка за один предмет. Результат - длина этого списка.


## Выводы

В ходе выполнения лабораторной работы я познакомился со структурой данных список в Прологе и научился совершать над ним различные операции, реализовал запросы к реляционному представлению данных в виде фактов Пролога.

Также я изучил особенность применения предикатов в Прологе, которые возможно использовать как для решения прямой задачи или проверки правильности данных, так и для решения обратной задачи. Однако способность выполнения обратной задачи зависит от реализации предиката.

В ходе написания предикатов обработки списков я применил два способа формулирования решения задачи в предикатах Пролога: составление "математического" определения данной операции и написание предиката, проверяющего переданные ему решения. Опытным путем выяснилось, что второй способ чаще приводит к предикатам, способным также и находить решения, возможно даже обратные. А первый способ может быть применен для чтения предикатов.
