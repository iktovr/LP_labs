#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Бирюков В.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       5       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Пространство состояний представляет собой способ представления задачи в виде множества ситуаций, каждая из которых однодначно описывает текущее состояние. Из одного состояния можно переходить в другое, совершая какое-либо действие. Такие действия образуют связи между состоянииями, что позволяет говорить о пространстве состояний как о графе. В таком виде удобно представлять задачи, которые имеют конкретные начальное и конечное состояния, так как возможно находить решения таких задач, выполняя поиск в пространстве состояний. Здесь полезны стандартные алгоритмы поиска путей в графах, которые работают не с матричным представлением, так как это является не самым удобным спобом задания графа в Прологе. Пролог позволяет удобно задавать граф в виде описания дуг, которые могут быть представлены как явным перечислением, так и при помощи более сложных выражений, что позволяет работать с большими, потенциально бесконечными графами.

## Задание

2\. Три миссионера и три каннибала хотят переправиться с левого берега реки на правый. Как это сделать за минимальное число шагов, если в их распоряжении имеется трехместная лодка и ни при каких обстоятельствах (в лодке или на берегу) миссионеры не должны оставаться в меньшинстве

## Принцип решения

Состояния задачи можно описать при помощи пяти переменных: число миссионеров на левом берегу, число каннибалов на левом берегу, положение лодки, число миссионеров на правом берегу, число каннибалов на правом берегу.

Из такого состояние можно перейти в другое, в котором лодка расположена на другом берегу, количество людей на этом берегу уменьшилось, а на другом - увеличилось, при этом должны выполняться условия задачи по соотношению миссионеров и каннибалов.

Начальное состояние - {3, 3, слева, 0, 0}. Конечное - {0, 0, справа, 3, 3}.

Переход из одного состояния в другое осуществляет предикат `move/2`, который меняет положение лодки и перебирает все варианты перемещения людей, которые соотвествуют условиям (проверка условий происходит при помощи предиката `check/2`).
```prolog
check(M, C) :- M = 0; M > 0, M >= C.

move(s(ML, CL, left, MR, CR), s(NML, NCL, right, NMR, NCR)) :-
	for(0, ML, M),
	for(0, CL, C),
	M+C > 0, M+C =< 3,
	lower(M, C),
	NML is ML-M, NCL is CL-C, NMR is MR+M, NCR is CR+C,
	lower(NML, NCL), lower(NMR, NCR).

move(s(ML, CL, right, MR, CR), s(NML, NCL, left, NMR, NCR)) :-
	for(0, MR, M),
	for(0, CR, C),
	M+C > 0, M+C =< 3,
	lower(M, C),
	NML is ML+M, NCL is CL+C, NMR is MR-M, NCR is CR-C,
	lower(NML, NCL), lower(NMR, NCR).
```

Для решения задачи использованы следующие алгоритмы поиска.

Поиск в глубину.
```prolog
dfs([X|T], X, [X|T]).
dfs(P1, X, Res) :-
	prolong(P1, P2),
	dfs(P2, X, Res).

path(dfs, X, Y, Path, Len) :- get_time(Start), dfs([X], Y, Path), get_time(End),
	length(Path, Len),
	write("Time: "), Time is End-Start, write(Time), nl, write_path(Path).
```

Поиск в ширину.
```prolog
bfs([[X|T]|_], X, [X|T]).
bfs([P|Q1],X,R) :-
	findall(Z, prolong(P,Z), T),
	append(Q1, T, Q2),
	bfs(Q2, X, R).
%% Было обнаружено, что в стандартных реализациях Пролога (SWI-Prolog, GNU-Prolog)
%% предикат findall возваращает пустой список при отсутствии решений, поэтому
%% этот случай можно не обрабатывать отдельно.

path(bfs, X, Y, Path, Len) :- get_time(Start), bfs([[X]], Y, Path), get_time(End),
	length(Path, Len),
	write("Time: "), Time is End-Start, write(Time), nl, write_path(Path).
```

Поиск с итерационным заглублением.
```prolog
num(1).
num(A) :- num(B), A is B + 1.

ids([X|T], X, [X|T], 0).
ids(P1, X, R, N) :- N > 0,
	prolong(P1, P2), N1 is N - 1,
	ids(P2, X, R, N1).

path(ids, X, Y, Path, Len) :- get_time(Start), num(Lvl), ids([X], Y, Path, Lvl), get_time(End),
	length(Path, Len),
	write("Time: "), Time is End-Start, write(Time), nl, write_path(Path).
```

Все варианты поиска используют вспомогательный предикат `prolong/2`, который продлевает путь, используя предикат `move` и предотвращая зацикливание.
```prolog
prolong([X|T],[Y,X|T]) :- move(X,Y), not(member(Y, [X|T])).
```

## Результаты

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|----------------|
| В глубину       | 12                             | 0.001008987    |
| В ширину        | 6                              | 0.002011061    |
| ID              | 6                              | 0.000988007    |

Примеры запросов:
```prolog
?- path(dfs, s(3,3,left,0,0), s(0,0,right,3,3), P, L).
Time: 0.008816957473754883
M: 3, C: 3 |Boat------| M: 0, C: 0
M: 3, C: 1 |------Boat| M: 0, C: 2
M: 3, C: 2 |Boat------| M: 0, C: 1
M: 3, C: 0 |------Boat| M: 0, C: 3
M: 3, C: 1 |Boat------| M: 0, C: 2
M: 1, C: 1 |------Boat| M: 2, C: 2
M: 2, C: 2 |Boat------| M: 1, C: 1
M: 0, C: 2 |------Boat| M: 3, C: 1
M: 0, C: 3 |Boat------| M: 3, C: 0
M: 0, C: 1 |------Boat| M: 3, C: 2
M: 0, C: 2 |Boat------| M: 3, C: 1
M: 0, C: 0 |------Boat| M: 3, C: 3
P = [s(0, 0, right, 3, 3), s(0, 2, left, 3, 1), s(0, 1, right, 3, 2), s(0, 3, left, 3, 0), s(0, 2, right, 3, 1), s(2, 2, left, 1, 1), s(1, 1, right, 2, 2), s(3, 1, left, 0, 2), s(..., ..., ..., ..., ...)|...],
L = 12 .

?- path(bfs, s(3,3,left,0,0), s(0,0,right,3,3), P, L).
Time: 0.001958131790161133
M: 3, C: 3 |Boat------| M: 0, C: 0
M: 3, C: 1 |------Boat| M: 0, C: 2
M: 3, C: 2 |Boat------| M: 0, C: 1
M: 0, C: 2 |------Boat| M: 3, C: 1
M: 0, C: 3 |Boat------| M: 3, C: 0
M: 0, C: 0 |------Boat| M: 3, C: 3
P = [s(0, 0, right, 3, 3), s(0, 3, left, 3, 0), s(0, 2, right, 3, 1), s(3, 2, left, 0, 1), s(3, 1, right, 0, 2), s(3, 3, left, 0, 0)],
L = 6 .

?- path(ids, s(3,3,left,0,0), s(0,0,right,3,3), P, L).
Time: 0.0009791851043701172
M: 3, C: 3 |Boat------| M: 0, C: 0
M: 3, C: 1 |------Boat| M: 0, C: 2
M: 3, C: 2 |Boat------| M: 0, C: 1
M: 0, C: 2 |------Boat| M: 3, C: 1
M: 0, C: 3 |Boat------| M: 3, C: 0
M: 0, C: 0 |------Boat| M: 3, C: 3
P = [s(0, 0, right, 3, 3), s(0, 3, left, 3, 0), s(0, 2, right, 3, 1), s(3, 2, left, 0, 1), s(3, 1, right, 0, 2), s(3, 3, left, 0, 0)],
L = 6 .
```

## Выводы

В ходе лабораторной работы я познакомился со способом представления задач в виде пространства состояний и с методом решения таким задач путем поиска в этом пространстве.

Можно заметить, что поиск в глубину работает быстро, но находит первым не самый короткий путь; поиск с итерационным заглублением тоже работает быстро и находит первым кратчайший путь; поиск в глубину также находит первым кратчайший путь, но работает дольше всех, так как обходит большую часть графа. Следовательно при поиске любого решения можно использовать поиск в глубину, но для нахождения кратчайшего решения больше подходит поиск с итерационным заглублением.
